+++
title = "Karpenter"
linkTitle = "Karpenter"

+++

{{< blocks/cover title="Welcome to Karpenter" image_anchor="top" color="orange" >}}
<div class="mx-auto">
	<a class="btn btn-lg btn-primary mr-3 mb-4" href="{{< relref "/docs" >}}">
		View Docs <i class="fas fa-arrow-alt-circle-right ml-2"></i>
	</a>
	<a class="btn btn-lg btn-primary mr-3 mb-4" href="{{< relref "/docs/getting-started" >}}">
		Get Started <i class="fas fa-arrow-alt-circle-right ml-2"></i>
	</a>
	<a class="btn btn-lg btn-secondary mr-3 mb-4" href="https://github.com/google/docsy-example">
		GitHub <i class="fab fa-github ml-2 "></i>
	</a>
	<p class="lead mt-5">Karpenter understands cloud instances, and intelligently provisions nodes </p>
	{{< blocks/link-down color="info" >}}
</div>
{{< /blocks/cover >}}


{{% blocks/lead color="primary" %}}
Karpenter is a node lifecycle management solution. It observes incoming pods and launches the right instances for the situation. Instance selection decisions are intent based and driven by the specification of incoming pods, including resource requests and scheduling constraints.
{{% /blocks/lead %}}

{{< blocks/section color="dark" >}}
{{% blocks/feature icon="fa-lightbulb" title="Launches nodes for unschedulable pods" %}}

{{% /blocks/feature %}}


{{% blocks/feature icon="fab fa-github" title="Replacing existing nodes to improve resource utilization" %}}
{{% /blocks/feature %}}


{{% blocks/feature icon="fab fa-twitter" title="Terminating nodes if outdated or no longer needed" %}}
{{% /blocks/feature %}}


{{< /blocks/section >}}

<div class="container pl-2">
	<p class="mt-3">
		For most use cases, the entirety of a clusterâ€™s capacity can be managed by a single Karpenter Provisioner. Availability zone, instance type, capacity type, machine image, and scheduling constraints are automatically determined by the controller using a combination of defaults and overrides. Additionally, you can define multiple Provisioners, enabling use cases like isolation, entitlements, and sharding.
	</p>
	<p>
		Karpenter optimizes for scheduling latency and utilization efficiency using two complementary control loops. First, is the allocator, a fast-acting latency-sensitive controller responsible for ensuring that incoming pods are scheduled as quickly as possible. Second, is the reallocator, a slow-acting cost-sensitive controller that replaces nodes as pods requests and capacity prices shift over time. Together, they maximize the availability and efficiency of your cluster.
	</p>
	<p>
		Come discuss Karpenter in the #provider-aws channel in the Kubernetes slack!
	</p>
	<p class="mb-3">
		Note: Reallocation is still in development. Check out the FAQs and Roadmap to learn more.
	</p>
  </div>




